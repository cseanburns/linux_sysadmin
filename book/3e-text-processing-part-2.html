<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Text Processing: Part 2 - Linux Systems Administration</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Entry level book on Linux systems administration.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux Systems Administration</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cseanburns/linux_sysadmin" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="text-processing-part-2"><a class="header" href="#text-processing-part-2">Text Processing: Part 2</a></h1>
<p>In this section, we will cover:</p>
<ol>
<li><strong>Expanding the toolbox</strong>: This section introduces more powerful text
processing utilities: <code>grep</code>, <code>sed</code>, and <code>awk</code>, which are essential for
advanced pattern matching, filtering, and text manipulation on the Linux
command line.</li>
<li><strong><code>grep</code> for pattern matching</strong>: The <code>grep</code> command allows you to search for
patterns in files and output matching lines. You can perform
case-insensitive searches, invert matches, count occurrences, and use
regular expressions to refine your searches.</li>
<li><strong><code>sed</code> for stream editing</strong>: <code>sed</code> is a non-interactive text editor
designed for filtering and transforming text. You can delete, replace, and
manipulate specific lines in a file, making it a powerful tool for batch
text processing tasks.</li>
<li><strong><code>awk</code> for structured data</strong>: <code>awk</code> is a complete scripting language for
pattern scanning and processing columns of structured data. It can handle
arithmetic, generate reports, and perform logical comparisons, making it
ideal for working with CSVs and other structured text files.</li>
<li><strong>Efficiency with one-liners</strong>: The combination of <code>grep</code>, <code>sed</code>, and <code>awk</code>
allows for creating powerful one-liner commands to process large amounts of
text quickly, reducing the need for more complex scripts.</li>
<li><strong>Regular expressions are key</strong>: Regular expressions (<strong>regex</strong>) play a
significant role in refining searches and manipulations in both <code>grep</code> and
<code>sed</code>. Understanding basic regex patterns, such as <code>^</code> for line start and
<code>$</code> for line end, is crucial for effective text processing.</li>
<li><strong>Integration with other tools</strong>: Like the tools introduced in Part 1,
<code>grep</code>, <code>sed</code>, and <code>awk</code> integrate well with pipes and redirection, allowing
you to chain them with other commands for flexible and efficient text
workflows.</li>
</ol>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>In the last section, we covered the <code>cat</code>, <code>cut</code>, <code>head</code>, <code>sort</code>, <code>tail</code>, <code>uniq</code>, and <code>wc</code> utilities.</p>
<p>We also learned about the <code>|</code> pipe operator.
The pipe operator is used to redirect <strong>standard output</strong> from one command to a second command.
Then the second command can process the output from the first command.
An example is:</p>
<pre><code>sort file.txt | uniq
</code></pre>
<p>This sorts the lines in a file named <strong>file.txt</strong> and then prints to standard output only the unique lines
Note that files must be sorted before piped to <code>uniq</code>.</p>
<p>We learned about the <code>&gt;</code> and <code>&gt;&gt;</code> redirect operators.
They work like the pipe operator, but instead of directing output to a new command, they direct output to a file for saving.
As a reminder, the single redirect <code>&gt;</code> overwrites a file or creates a file if it does not exist.
The double redirect <code>&gt;&gt;</code> appends to a file or creates a file if it does not exist.
It's safer to use the double redirect, but if you are processing large amounts of data, it could also mean creating large files really quickly.
If that gets out of hand, then you might crash your system.
To build on our prior example, we can add <code>&gt;&gt;</code> to send the output to a new file called <strong>output.txt</strong>:</p>
<pre><code>sort file.txt | uniq &gt;&gt; output.txt
</code></pre>
<p>We have available more powerful utilities and programs to process, manipulate, and analyze text files.
In this section, we will cover the following three of these:</p>
<ul>
<li><code>grep</code> : print lines that match patterns</li>
<li><code>sed</code>  : stream editor for filtering and transforming text</li>
<li><code>awk</code>  : pattern scanning and text processing language</li>
</ul>
<h2 id="grep"><a class="header" href="#grep">Grep</a></h2>
<p>The <code>grep</code> command is one of my most often used commands.
Basically, <code>grep</code> "prints lines that match patterns" (see <code>man grep</code>).
In other words, it's search, and it's super powerful.</p>
<p><code>grep</code> works line by line.
So when we use it to search a file for a <strong>string</strong> of text, it will return the whole line that matches the string.
This <strong>line by line</strong> idea is part of the history of Unix-like operating systems.
It's super important to remember that most utilities and programs that we use on the commandline are line oriented.</p>
<blockquote>
<p>"A string is any series of characters that are interpreted literally by a
script. For example, 'hello world' and 'LKJH019283' are both examples of
strings." -- <a href="https://www.computerhope.com/jargon/s/string.htm">Computer Hope</a>. More generally, it's the literal
characters that we type. It's data.</p>
</blockquote>
<p>Let's consider the file <strong>operating-systems.csv</strong>, as seen below:</p>
<pre><code>OS, License, Year
Chrome OS, Proprietary, 2009
FreeBSD, BSD, 1993
Linux, GPL, 1991
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<p>If we want to search for the string <strong>Chrome</strong>, we can use <code>grep</code>.
Notice that even though the string <strong>Chrome</strong> only appears once, and in one part of a line, <code>grep</code> returns the entire line.</p>
<p><strong>Command:</strong></p>
<pre><code>grep "Chrome" operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Chrome OS, Proprietary, 2009
</code></pre>
<p>Be aware that, by default, <code>grep</code> is case-sensitive, which means a search for the string <strong>chrome</strong>, with a lower case <strong>c</strong>, would return no results.
Fortunately, <code>grep</code> has an <code>-i</code> option, which means to ignore the case of the search string.
In the following examples, <code>grep</code> returns nothing in the first search since we do not capitalize the string <strong>chrome</strong>.
However, adding the <code>-i</code> option results in success:</p>
<p><strong>Command:</strong></p>
<pre><code>grep "chrome" operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<p>None.</p>
<p><strong>Command:</strong></p>
<pre><code>grep -i "chrome" operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Chrome OS, Proprietary, 2009
</code></pre>
<p>We can also search for lines that <strong>do not</strong> match our string  using the <code>-v</code> option.
We can combine that with the <code>-i</code> option to ignore the string's case.
Therefore, in the following example, all lines that do not contain the string <strong>chrome</strong> are returned:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -vi "chrome" operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>FreeBSD, BSD, 1993
Linux, GPL, 1991
iOS, Proprietary, 2007
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<p>I used the <code>tail</code> command in the prior section to show how we might use <code>tail</code> to remove the header (1st line) line in a file.
However, it's an odd use of the <code>tail</code> command, which normally just prints the last lines of a file.
Instead, we can use <code>grep</code> to remove the first line.
To do so, we use what's called a <strong>regular expression</strong>, or <strong>regex</strong> for short.
Regex is a method used to identify patterns in text via abstractions.
They can get complicated, but we can use some easy regex methods.</p>
<p>Let's use a version of the above file with the header line:</p>
<p><strong>Command:</strong></p>
<pre><code>cat operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>OS, License, Year
Chrome OS, Proprietary, 2009
FreeBSD, BSD, 1993
Linux, GPL, 1991
iOS, Proprietary, 2007
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<p>To use <code>grep</code> to remove the first line of a file, we can invert our search to select all lines not matching "OS" at the start of a line.
Here the carat key <code>^</code> is a <strong>regex</strong> indicating the start of a line.
Again, this <code>grep</code> command returns all lines that do not match the string <strong>os</strong> at the start of a line, ignoring case:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -vi "^os" operating-systems.csv
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>Chrome OS, Proprietary, 2009
FreeBSD, BSD, 1993
Linux, GPL, 1991
iOS, Proprietary, 2007
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<p>Alternatively, since we know that the string <strong>Year</strong> comes at the end of the first line,
we can use <code>grep</code> to invert a search for that.
Here the dollar sign key <code>$</code> is a <strong>regex</strong> indicating the end of a line.
Like the above, this <code>grep</code> command returns all lines that do not match the string <strong>year</strong> at the end of a line, ignoring case:</p>
<p><strong>Command</strong>:</p>
<pre><code>grep -vi "year$" operating-systems.csv
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>Chrome OS, Proprietary, 2009
FreeBSD, BSD, 1993
Linux, GPL, 1991
iOS, Proprietary, 2007
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<p>The <code>man grep</code> page lists other options, but a couple of other good ones include:</p>
<p>Get a count of the matching lines with the <code>-c</code> option:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -ic "proprietary" operating-systems.csv
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>4
</code></pre>
<p>Print only the match and not the whole line with the <code>-o</code> option:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -io "proprietary" operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Proprietary
Proprietary
Proprietary
Proprietary
</code></pre>
<p>We can simulate a Boolean OR search, and print lines matching one or both strings using the <code>-E</code> option.
We separate the strings with a vertical bar <code>|</code>.
This is similar to a Boolean OR search since there's at least one match in the following string,
there is at least one result.</p>
<p>Here is an example where only one string returns a true value:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -Ei "bsd|atari" operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>FreeBSD, BSD, 1993
</code></pre>
<p>Here's an example where both strings evaluate to true:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -Ei "bsd|gpl" operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>FreeBSD, BSD, 1993
Linux, GPL, 1991
</code></pre>
<p>By default, <code>grep</code> will return results where the string appears within a larger word, like <strong>OS</strong> in <strong>macOS</strong>.</p>
<p><strong>Command:</strong></p>
<pre><code>grep -i "os" operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>OS, License, Year
Chrome OS, Proprietary, 2009
iOS, Proprietary, 2007
macOS, Proprietary, 2001
</code></pre>
<p>However, we might want to limit results so that we only return results where <strong>OS</strong> is a complete word.
To do that, we can surround the string with special characters:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -i "\&lt;os\&gt;" operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>OS, License, Year
Chrome OS, Proprietary, 2009
</code></pre>
<p>Sometimes we want the context for a result.
That is, we might want to print lines that surround our matches.
For example, print the matching line plus the two lines after the matching line using the <code>-A NUM</code> option:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -i "chrome" -A 2 operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Chrome OS, Proprietary, 2009
FreeBSD, BSD, 1993
Linux, GPL, 1991
</code></pre>
<p>Or, print the matching line plus the two lines before the matching line using the <code>-B NUM</code> option:</p>
<p><strong>Command</strong></p>
<pre><code>grep -i "android" -B 2 operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<p>We can combine many of the variations.
Here I search for the whole word <strong>BSD</strong>, case insensitive, and print the line before and the line after the match:</p>
<p><strong>Command:</strong></p>
<pre><code>grep -i -A 1 -B 1 "\&lt;bsd\&gt;" operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Chrome OS, Proprietary, 2009
FreeBSD, BSD, 1993
Linux, GPL, 1991
</code></pre>
<p><code>grep</code> is very powerful, and there are more options listed in its <code>man</code> page.</p>
<blockquote>
<p>Note that I enclose my search strings in double quotes. For example: <code>grep "search string" filename.txt</code> It's not always required to enclose a search
string in double quotes, but it's good practice because if your string
contains more than one word or empty spaces, the search will fail.</p>
</blockquote>
<h2 id="sed"><a class="header" href="#sed">Sed</a></h2>
<p><code>sed</code> is a type of non-interactive text editor that filters and transforms text (<code>man sed</code>).
By default <code>sed</code> works on <strong>standard output</strong>, and edits can be redirected (<code>&gt;</code> or <code>&gt;&gt;</code>) to new files or made <strong>in-place</strong> using the <code>-i</code> option.</p>
<p>Like the other utilities and programs we've covered, including <code>grep</code>, <code>sed</code> works line by line.
But unlike <code>grep</code>, <code>sed</code> provides a way to <strong>address</strong> specific lines or ranges of lines,
and then run filters or transformations on those lines.
Once lines in a text file have been identified or addressed, <code>sed</code> offers commands to filter or transform the text at those specific lines.</p>
<p>This concept of the line address is important, but not all text files are explicitly line numbered.
Below I use the <code>nl</code> command to number lines in our file, even though the contents of the file do not actually display line numbers:</p>
<p><strong>Command:</strong></p>
<pre><code>nl operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>     1	OS, License, Year
     2	Chrome OS, Proprietary, 2009
     3	FreeBSD, BSD, 1993
     4	Linux, GPL, 1991
     5	iOS, Proprietary, 2007
     6	macOS, Proprietary, 2001
     7	Windows NT, Proprietary, 1993
     8	Android, Apache, 2008
</code></pre>
<p>After we've identified the lines in a file that we want to edit, <code>sed</code> offers commands to filter, transform, or edit the text at the line addresses.
Some of these commands include:</p>
<ul>
<li><code>a</code> : appending text</li>
<li><code>c</code> : replace text</li>
<li><code>d</code> : delete text</li>
<li><code>i</code> : inserting text</li>
<li><code>p</code> : print text</li>
<li><code>r</code> : append text from file</li>
<li><code>s</code> : substitute text</li>
<li><code>=</code> : print the current line number</li>
</ul>
<p>Let's see how to use <code>sed</code> to print line numbers instead of using the <code>nl</code> command.
To do so, we use the equal sign <code>=</code> to identify line numbers.
Note that it places the line numbers just above each line:</p>
<p><strong>Command:</strong></p>
<pre><code>sed '=' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>1
OS, License, Year
2
Chrome OS, Proprietary, 2009
3
FreeBSD, BSD, 1993
4
Linux, GPL, 1991
5
iOS, Proprietary, 2007
6
macOS, Proprietary, 2001
7
Windows NT, Proprietary, 1993
8
Android, Apache, 2008
</code></pre>
<p>In the last section, we used the <code>tail</code> command to remove the header line of our file.
Above, we used <code>grep</code> to accomplish this task.
It's much easier to use <code>sed</code> to remove the header line of the <strong>operating-systems.csv</strong>.
We simply specify the line number (<code>1</code>) and then use the delete command (<code>d</code>).
Thus, we delete line 1 with the command below.
As long as we don't use the <code>-i</code> operator, we don't change the actual file.</p>
<p><strong>Command:</strong></p>
<pre><code>sed '1d' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Chrome OS, Proprietary, 2009
FreeBSD, BSD, 1993
Linux, GPL, 1991
iOS, Proprietary, 2007
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<blockquote>
<p>Note that I use single apostrophes for the <code>sed</code> command.
This is required.</p>
</blockquote>
<p>If I wanted to make that a permanent deletion, then I would use the <code>-i</code> option, which means that I would edit the file <strong>in-place</strong> (see <code>man sed</code>):</p>
<p><strong>Command:</strong></p>
<pre><code>sed -i '1d' operating-systems.csv
</code></pre>
<p>To refer to line <strong>ranges</strong>, I add a comma between <strong>addresses</strong>.
Therefore, to edit lines 1, 2, and 3:</p>
<p><strong>Command:</strong></p>
<pre><code>sed '1,3d' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Linux, GPL, 1991
iOS, Proprietary, 2007
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<p>I can use <code>sed</code> to <strong>find and replace</strong> strings.
The syntax for this is:</p>
<pre><code>sed 's/regexp/replacement/' filename.txt
</code></pre>
<p>The <strong>regexp</strong> part of the above command is where I place regular expressions.
Simple strings like words work here, too, since they are treated as regular expressions themselves.</p>
<p>In the next example, I use <code>sed</code> to search for the string "Linux", and replace it with the string "GNU/Linux":</p>
<p><strong>Command:</strong></p>
<pre><code>sed 's/Linux/GNU\/Linux/' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>OS, License, Year
Chrome OS, Proprietary, 2009
FreeBSD, BSD, 1993
GNU/Linux, GPL, 1991
iOS, Proprietary, 2007
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<blockquote>
<p>Because the string <strong>GNU/Linux</strong> contains a forward slash, and because
<code>sed</code> uses the forward slash as a separator, note that I <strong>escaped</strong> the
forward slash with a back slash. This escape tells <code>sed</code> to interpret the
forward slash in <strong>GNU/Linux</strong> literally and not as a special <code>sed</code>
character.</p>
</blockquote>
<p>If we want to add new rows to the file, we can append <code>a</code> or insert <code>i</code> text after or at specific lines:</p>
<p>To append text <strong>after line 3</strong>, use <code>a</code>:</p>
<p><strong>Command:</strong></p>
<pre><code>sed '3a FreeDOS, GPL, 1998' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>OS, License, Year
Chrome OS, Proprietary, 2009
FreeBSD, BSD, 1993
FreeDOS, GPL, 1998
Linux, GPL, 1991
iOS, Proprietary, 2007
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<p>To insert <strong>at line 3</strong>, use <code>i</code>:</p>
<p><strong>Command:</strong></p>
<pre><code>sed '3i CP\/M, Proprietary, 1974' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>OS, License, Year
Chrome OS, Proprietary, 2009
CP/M, Proprietary, 1974
FreeBSD, BSD, 1993
Linux, GPL, 1991
iOS, Proprietary, 2007
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<p>Note that the FreeDOS line doesn't appear in the last output.
This is because I didn't use the <code>-i</code> option nor
did I redirect output to a new file.
If we want to edit the file <strong>in-place</strong>, that is, save the edits, then the commands would look like so:</p>
<pre><code>sed -i '3a FreeDOS, GPL, 1998' operating-systems.csv
sed -i '3i CP\/M, Proprietary, 1974' operating-systems.csv
</code></pre>
<p>Instead of using line numbers to specify addresses in a text file, we can use regular expressions as addresses, which may be simple words.
In the following example, I use the regular expression <code>1991$</code> instead of specifying line 4.
The regular expression <code>1991$</code>  means <strong>lines ending with the string 1991</strong>.
Then I use the <code>s</code> command to start a find and replace.
<code>sed</code> finds the string <strong>Linux</strong> and then replaces that with the string <strong>GNU/Linux</strong>.
I use the back slash to escape the forward slash in GNU/Linux:</p>
<p><strong>Command:</strong></p>
<pre><code>sed '/1991$/s/Linux/GNU\/Linux/' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>OS, License, Year
Chrome OS, Proprietary, 2009
FreeBSD, BSD, 1993
GNU/Linux, GPL, 1991
iOS, Proprietary, 2007
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<p>Here's an example using <code>sed</code> to simply search for a pattern.
In this example, I'm interested in searching for all operating systems that were released on or after 2000:</p>
<p><strong>Command:</strong></p>
<pre><code>sed -n '/20/p' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Chrome OS, Proprietary, 2009
iOS, Proprietary, 2007
macOS, Proprietary, 2001
Android, Apache, 2008
</code></pre>
<p>The above would be equivalent to:</p>
<pre><code>grep "20" operating-systems.csv
</code></pre>
<p><code>sed</code> is much more powerful than what I've demonstrated here, and if you're interested in learning more, there are lots of tutorials on the web.
Here are a few good ones:</p>
<ul>
<li><a href="https://opensource.com/article/20/12/sed">Learn to use the Sed text editor</a></li>
<li><a href="https://www.gnu.org/software/sed/manual/sed.html">Sed Introduction</a></li>
<li><a href="https://catonmat.net/sed-one-liners-explained-part-one">Sed One-Liners Explained, Part I: File Spacing, Numbering and Text Conversion and Substitution</a></li>
<li><a href="https://edoras.sdsu.edu/doc/sed-oneliners.html">sed one-liners</a></li>
<li><a href="https://www.tutorialspoint.com/sed/index.htm">Sed Tutorial</a></li>
</ul>
<h2 id="awk"><a class="header" href="#awk">Awk</a></h2>
<p><code>awk</code> is a complete scripting language designed for "pattern scanning and processing" text.
It generally performs some <strong>action</strong> when it detects some <strong>pattern</strong> and is particularly suited for <strong>columns of structured data</strong>.
See <code>man awk</code>for documentation..</p>
<p><code>awk</code> works on columns  regardless if the contents include structured data  (like a CSV file) or not (like a letter or essay).
If the data is structured, then that means the data will be formatted in some way.
In the last few sections, we have looked at a CSV file.
This is structured data because the data points  in this file are separated by commas.</p>
<p>For <code>awk</code> to work with columns in a file, it needs some way to refer to those columns.
In the examples below, we'll see that columns in a text file are referred to by a dollar sign and then the number of the column <code>$n</code>.
So, <code>$1</code> indicates column one,  <code>$2</code> indicates column two, and so on.
If we use <code>$0</code>, then we refer to the entire file.
In our example text file, <code>$1</code> indicates the OS Name column, <code>$2</code> indicates the License column, <code>$3</code> indicates the release Year column,
and <code>$0</code> indicates all columns.</p>
<p>The syntax for <code>awk</code> is a little different than what we've seen so far.
Basically, <code>awk</code> uses the following syntax, where <strong>pattern</strong> is optional.</p>
<pre><code>awk pattern { action statements }
</code></pre>
<p>Let's see some examples.</p>
<p>To print the first column of our file, we do not need the <strong>pattern</strong> part of the command but only need to state an action statement within curly braces.
In the command below, the action statement is <code>'{ print $1 }'</code>.</p>
<p><strong>Command:</strong></p>
<pre><code>awk '{ print $1 }' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>OS,
Chrome
FreeBSD,
Linux,
iOS,
macOS,
Windows
Android,
</code></pre>
<p>By default, <code>awk</code> considers the first empty space as the field delimiter.
That's why in the command above only the term <strong>Windows</strong> and <strong>Chrome</strong> appear in the results even though it should be <strong>Windows NT</strong> and <strong>Chrome OS</strong>.
It's also why we see commas in the output.
To fix this, we tell <code>awk</code> to use a comma as the field separator, instead of the default empty space.
To specify that we want <code>awk</code> to treat the comma as a field delimiter,
we use the <code>-F</code> option, and we surround the comma with single quotes:</p>
<p><strong>Command:</strong></p>
<pre><code>awk -F',' '{ print $1 }' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>OS
Chrome OS
FreeBSD
Linux
iOS
macOS
Windows NT
Android
</code></pre>
<p>By specifying the comma as the field separator, our results are more accurate, and the commas no longer appear either.</p>
<p>Like <code>grep</code> and <code>sed</code>, <code>awk</code> can do search.
In this next example, I print the column containing the string <strong>Linux</strong>.
Here I am using the <strong>pattern</strong> part of the command: <code>'/Linux/'</code>.</p>
<p><strong>Command:</strong></p>
<pre><code>awk -F',' '/Linux/ { print $1 }' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Linux
</code></pre>
<p>Note how <code>awk</code> does not return the whole line but only the match.</p>
<p>With <code>awk</code>, we can retrieve more than one column, and we can use <code>awk</code> to generate reports.
This was part of the original motivation to create this language.</p>
<p>In the next example, I select columns two and one in that order, which is something the <code>cut</code> command cannot do.
I also add a space between the columns using the double quotes to surround an empty space.
Then I modified the field delimiter to include both a comma and a space to get the output that I want:</p>
<p><strong>Command:</strong></p>
<pre><code>awk -F', ' '{ print $2 " " $1 }' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>License OS
Proprietary Chrome OS
BSD FreeBSD
GPL Linux
Proprietary iOS
Proprietary macOS
Proprietary Windows NT
Apache Android
</code></pre>
<p>I can make output more readable by adding text to print:</p>
<p><strong>Command:</strong></p>
<pre><code>awk -F',' '{ print $1 " was released in" $3 "." }' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>OS was released in Year.
Chrome OS was released in 2009.
FreeBSD was released in 1993.
Linux was released in 1991.
iOS was released in 2007.
macOS was released in 2001.
Windows NT was released in 1993.
Android was released in 2008.
</code></pre>
<p>Since <code>awk</code> is a full-fledged programming language, it understands data structures, which means it can do math or work on strings of text.
Let's illustrate this by doing some math or logic on column 3.</p>
<p>Here I print all of column three:</p>
<p><strong>Command:</strong></p>
<pre><code>awk -F',' '{ print $3 }' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code> Year
 2009
 1993
 1991
 2007
 2001
 1993
 2008
</code></pre>
<p>Next I print only the parts of column three that are greater than 2005, and
then pipe <code>|</code> the output through the <code>sort</code> command to sort the numbers in numeric order:</p>
<p><strong>Command:</strong></p>
<pre><code>awk -F',' '$3 &gt; 2005 { print $3 }' operating-systems.csv | sort
</code></pre>
<p><strong>Output:</strong></p>
<pre><code> 2007
 2008
 2009
</code></pre>
<p>If I want to print only the parts of column one where column three equals to 2007, then I would run this command:</p>
<p><strong>Command:</strong></p>
<pre><code>awk -F',' '$3 == 2007 { print $1 }' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>iOS
</code></pre>
<p>If I want to print only the parts of columns one and three where column 3 equals 2007:</p>
<p><strong>Command:</strong></p>
<pre><code>awk -F',' '$3 == 2007 { print $1 $3 }' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>iOS 2007
</code></pre>
<p>Or, print the entire line where column three equals 2007:</p>
<p><strong>Command:</strong></p>
<pre><code>awk -F',' '$3 == 2007 { print $0 }' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>iOS, Proprietary, 2007
</code></pre>
<p>I can print only those lines where column three is greater than 2000 and less than 2008:</p>
<p><strong>Command:</strong></p>
<pre><code>awk -F',' '$3 &gt; 2000 &amp;&amp; $3 &lt; 2008 { print $0 }' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>iOS, Proprietary, 2007
macOS, Proprietary, 2001
</code></pre>
<p>Even though we wouldn't normally sum years, let's print the sum of column three  to demonstrate how summing works in <code>awk</code>:</p>
<p><strong>Command:</strong></p>
<pre><code>awk -F',' 'sum += $3 { print sum }' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>2009
4002
5993
8000
10001
11994
14002
</code></pre>
<p>Here are a few basic string operations.
First, print column one in upper case:</p>
<p><strong>Command:</strong></p>
<pre><code>awk -F',' '{ print toupper($1) }' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>OS
CHROME OS
FREEBSD
LINUX
IOS
MACOS
WINDOWS NT
ANDROID
</code></pre>
<p>Or print column on in lower case:</p>
<p><strong>Command:</strong></p>
<pre><code>awk -F',' '{ print tolower($1) }' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>os
chrome os
freebsd
linux
ios
macos
windows nt
android
</code></pre>
<p>Or, get the length of each string in column one:</p>
<p><strong>Command:</strong></p>
<pre><code>awk -F',' '{ print length($1) }' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>2
9
7
5
3
5
10
7
</code></pre>
<p>We can add additional logic.
The double ampersands <code>&amp;&amp;</code> indicate a Boolean/Logical <strong>AND</strong>.
The exclamation point <code>!</code> indicates a Boolean/Logical <strong>NOT</strong>.
In the next example, I print only those lines where column three is greater than 1990, and the line has the string "BSD" in it:</p>
<p><strong>Command:</strong></p>
<pre><code>awk -F',' '$3 &gt; 1990 &amp;&amp; /BSD/ { print $0 }' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>FreeBSD, BSD, 1993
</code></pre>
<p>Now I reverse that, and print only those lines where column three is greater than 1990 and the line DOES NOT have the string "BSD" in it:</p>
<p><strong>Command:</strong></p>
<pre><code>awk -F',' '$3 &gt; 1990 &amp;&amp; !/BSD/ { print $0 }' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Chrome OS, Proprietary, 2009
Linux, GPL, 1991
iOS, Proprietary, 2007
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<p>The double vertical bar <code>||</code> indicates a Boolean/Logical <strong>OR</strong>.
The next command prints only those lines that contain the string "Proprietary" or the string "Apache",
or it would print both if both strings were in the text:</p>
<p><strong>Command:</strong></p>
<pre><code>awk -F',' '/Proprietary/ || /Apache/ { print $0 }' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Chrome OS, Proprietary, 2009
iOS, Proprietary, 2007
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<p>I can take advantage of regular expressions.
If I needed to analyze a large file and wasn't sure that some fields would be upper or lower case,
then I could use regular expressions to consider both possibilities.
That is, by adding <strong>[pP]</strong> and <strong>[aA]</strong>, <code>awk</code> will check for both the words <strong>Proprietary</strong> and <strong>proprietary</strong>, and <strong>Apache</strong> and <strong>apache</strong>.</p>
<p><strong>Command:</strong></p>
<pre><code>awk -F',' '/[pP]roprietary/ || /[aA]pache/ { print $0 }' operating-systems.csv
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Chrome OS, Proprietary, 2009
iOS, Proprietary, 2007
macOS, Proprietary, 2001
Windows NT, Proprietary, 1993
Android, Apache, 2008
</code></pre>
<p><code>awk</code> is full-fledged programming language.
It provides conditionals, control structures, variables, etc., and so I've only scratched the surface.
If you're interested in learning more, then check out some of these tutorials:</p>
<ul>
<li><a href="https://www.tecmint.com/category/awk-command/">Awk Command</a></li>
<li><a href="https://catonmat.net/awk-one-liners-explained-part-one">Awk One-Liners Explained, Part I: File Spacing, Numbering and Calculations</a></li>
<li><a href="https://www.grymoire.com/Unix/Awk.html">Awk Tutorial</a></li>
<li><a href="https://blog.robertelder.org/intro-to-awk-command/">How To Become a 10x Engineer using the Awk Command</a></li>
<li><a href="https://arstechnica.com/gadgets/2021/08/linux-bsd-command-line-101-using-awk-sed-and-grep-in-the-terminal/">Linux/BSD command line wizardry: Learn to think in sed, awk, and grep</a></li>
<li><a href="https://earthly.dev/blog/awk-examples/">Understanding AWK</a></li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>The Linux command line offers a lot of utilities to examine data.
Prior to this lesson, we covered a few of them that helped us get parts of a file and
then pipe those parts through other commands or redirect output to files.
We can use pipes and redirects with <code>grep</code>, <code>sed</code>, and <code>awk</code>.
If needed, we may be able to avoid using the basic utilities like
<code>cut</code>, <code>wc</code>, etc if want to learn more powerful programs like <code>grep</code>, <code>sed</code>, and <code>awk</code>.</p>
<p>It's fun to learn and practice these.
Despite this, you do not have to become a <code>sed</code> or an <code>awk</code> programmer.
Like the utilities that we've discussed in prior lectures, the power of programs like these is that they are easy to use as <strong>one-liners</strong>.
If you want to get started, the resources listed above can guide you.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="3d-text-processing-part-1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="3f-regular-expressions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="3d-text-processing-part-1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="3f-regular-expressions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
